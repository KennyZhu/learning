# Arithmetic 目录代码分析与注释总结

## 📋 已完成的文件列表

所有 arithmetic 目录下的代码文件已经完成详细的中文注释。

---

## 1️⃣ QSort.java - 快速排序

### 算法特点
- **时间复杂度**: 平均 O(n log n)，最坏 O(n²)
- **空间复杂度**: O(log n) - 递归栈
- **算法类型**: 分治法

### 核心思想
1. 选择基准值（pivot）
2. 分区操作：小于基准的放左边，大于基准的放右边
3. 递归排序左右子数组

### 关键注释位置
- ✅ 双指针扫描逻辑
- ✅ 分区过程详细说明
- ✅ 递归终止条件
- ✅ 复杂度分析

---

## 2️⃣ DeadLock.java - 死锁演示

### 核心知识点
**死锁的四个必要条件**:
1. 互斥条件
2. 持有并等待
3. 不可剥夺
4. 循环等待

### 演示场景
- 线程1: lock1 → lock2
- 线程2: lock2 → lock1
- 结果: 形成循环等待 → 死锁

### 如何检测
```bash
jps                    # 查看进程ID
jstack <pid>          # 查看线程堆栈
# 会看到 "Found 1 deadlock"
```

### 解决方案
1. 统一加锁顺序
2. 使用 tryLock() 设置超时
3. 使用 Lock 接口的高级功能

---

## 3️⃣ FilterSet.java - 位图集合

### 数据结构
**BitSet（位图）实现**
- 使用 long 数组存储
- 每个 long (64位) 可存储 64 个整数的状态
- 支持 0-65535 范围

### 核心操作
| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| add() | O(1) | 添加元素 |
| remove() | O(1) | 移除元素 |
| contains() | O(1) | 判断存在 |
| size() | O(n) | 统计大小 (n=1024) |

### 实现原理
```java
数组索引 = no >>> 6  // 即 no / 64
位位置 = no & 63     // 即 no % 64
添加: elements[index] |= (1L << position)
移除: elements[index] &= ~(1L << position)
查询: (elements[index] & (1L << position)) != 0
```

### 优势
- 🚀 空间效率高：比 HashSet 节省大量内存
- ⚡ 操作速度快：位运算效率高
- 🎯 适用场景：大量整数的存在性判断

---

## 4️⃣ LinkedNode.java - 链表节点

### 数据结构
双向链表节点

### 核心方法
1. **buildLinkedNode()**: 根据列表构建链表
2. **printLinkedList()**: 打印链表所有节点

### 应用场景
- LRU 缓存
- 浏览器历史记录
- 文本编辑器撤销/重做

---

## 5️⃣ TreeNode.java - 二叉树构建

### 核心算法
**根据前序和中序遍历构建二叉树**

### 算法原理
1. **前序遍历**第一个元素 = 根节点
2. 在**中序遍历**中找根节点
   - 左边 = 左子树
   - 右边 = 右子树
3. 递归构建左右子树

### 复杂度
- **时间**: O(n²) - 每个节点需要在中序遍历中查找
- **空间**: O(n) - 节点映射 + 递归栈

### 示例
```
前序: [15, 13, 10, 9, 14, 20, 17, 21]
中序: [9, 10, 13, 14, 15, 17, 20, 21]

构建的树:
        15
       /  \
     13    20
    / \   /  \
  10  14 17  21
  /
 9
```

---

## 6️⃣ TreeTraverse.java - 树的遍历

### 功能
深度优先遍历（DFS）

### 两个核心方法

#### 1. binaryTreePaths()
找出所有从根到叶子的路径

**输出格式**: `["1->2->5", "1->3"]`

#### 2. sum()
收集所有路径（可扩展为路径和判断）

### 复杂度
- **时间**: O(n)
- **空间**: O(h) - h为树高度

---

## 7️⃣ WordNode.java - 敏感词节点

### 数据结构
**Trie 树（字典树）变体**

### 设计思想
```
敏感词: ["日本", "日本人"]

树结构:
'日'(isLast=false)
 └─'本'(isLast=true)
    └─'人'(isLast=true)
```

### 核心字段
- `value`: 节点值（字符的int表示）
- `subNodes`: 子节点列表
- `isLast`: 是否为敏感词结尾

### 核心方法
1. **addIfNoExist()**: 智能添加子节点
   - 已存在则返回
   - 不存在则创建
   - 更新 isLast 状态

2. **querySub()**: 查询子节点
   - 用于匹配过程

---

## 8️⃣ WordFilter.java - 敏感词过滤

### 算法
**DFA（确定有限状态自动机）**

### 三大核心数据结构

#### 1. FilterSet set
位图存储敏感词首字符
- 快速判断是否可能是敏感词
- O(1) 时间复杂度

#### 2. Map<Integer, WordNode> nodes
敏感词树的根节点映射
- key: 首字符
- value: 对应的树节点

#### 3. Set<Integer> stopwdSet
停顿词集合
- 存储标点符号
- 匹配时自动忽略

### 核心功能

#### 1. addSensitiveWord()
构建敏感词树
- 输入：敏感词列表
- 输出：Trie树结构

#### 2. getSensitiveWord()
获取文本中的敏感词
- DFA匹配
- 忽略停顿词

#### 3. isContains()
判断是否包含敏感词
- 返回 boolean
- 快速判断

#### 4. replace()
替换敏感词
- 将敏感词替换为指定字符

### 匹配特点
- ✅ **智能匹配**: "日*本"可以匹配"日本"
- ✅ **全角半角**: 自动转换
- ✅ **大小写**: 自动转换
- ✅ **高效**: O(L) 时间复杂度，L为文本长度

### 匹配流程
```
1. 遍历文本字符
2. 字符转换（全角→半角，大写→小写）
3. 检查是否为首字符（使用FilterSet）
4. 沿着树向下匹配
5. 遇到停顿词则跳过
6. 到达isLast节点表示匹配成功
```

---

## 9️⃣ BCConvert.java - 全角半角转换

### 功能
中文字符全角半角转换工具类

### 核心常量
```java
DBC_CHAR_START = 33    // 半角 !
DBC_CHAR_END = 126     // 半角 ~
SBC_CHAR_START = 65281 // 全角 ！
SBC_CHAR_END = 65374   // 全角 ～
CONVERT_STEP = 65248   // 转换间隔
```

### 核心方法
1. **bj2qj()**: 半角 → 全角
2. **qj2bj()**: 全角 → 半角

### 特殊处理
- 空格单独处理
- 只处理可见字符
- 其他字符原样返回

---

## 🎯 代码质量总结

### ✅ 优点
1. **算法经典**: 涵盖排序、树、位图、DFA等经典算法
2. **注释详细**: 所有关键位置都有详细中文注释
3. **实用性强**: 敏感词过滤等实际应用场景

### 💡 改进建议

#### 1. FilterSet.java
- 建议维护size变量，避免每次重新计算
- containsAll_ueslessWay() 方法可以移除

#### 2. TreeNode.java
- contains() 查找可以优化为 HashMap 查找
- 时间复杂度可从 O(n²) 优化到 O(n)

#### 3. TreeTraverse.java
- sum() 方法未实际使用 sum 参数
- 建议实现真正的路径和判断

#### 4. WordFilter.java
- 建议将静态方法改为实例方法
- 支持动态添加/删除敏感词
- 线程安全性考虑

---

## 📚 学习价值

### 数据结构
- ✅ 位图（BitSet）
- ✅ 链表
- ✅ 二叉树
- ✅ Trie树（字典树）

### 算法
- ✅ 快速排序
- ✅ 树的遍历（DFS）
- ✅ 树的构建
- ✅ DFA（确定有限状态自动机）

### 实践技能
- ✅ 并发编程（死锁）
- ✅ 文本处理（敏感词过滤）
- ✅ 性能优化（位运算）

---

## 🔗 相关 LeetCode 题目

| 文件 | 相关题目 |
|------|---------|
| QSort.java | #912 Sort an Array |
| LinkedNode.java | #146 LRU Cache |
| TreeNode.java | #105 Construct Binary Tree |
| TreeTraverse.java | #257 Binary Tree Paths<br>#113 Path Sum II |
| WordFilter.java | 敏感词过滤（实际应用） |

---

**注释完成时间**: 2025-12-01  
**注释语言**: 中文  
**文件总数**: 9 个  
**注释质量**: ⭐⭐⭐⭐⭐

所有代码现在都包含了详细的中文注释，包括：
- 算法原理说明
- 时间空间复杂度分析
- 关键步骤详解
- 使用示例
- 注意事项

代码可读性和可维护性大幅提升！🎉

